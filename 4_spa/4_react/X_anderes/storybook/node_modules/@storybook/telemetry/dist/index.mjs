import { logger as logger$1 } from '@storybook/client-logger';
import readPkgUp from 'read-pkg-up';
import { detect, getNpmVersion } from 'detect-package-manager';
import { getProjectRoot, getStorybookInfo, getStorybookConfiguration, loadMainConfig, cache, frameworkPackages } from '@storybook/core-common';
import * as fs2 from 'fs-extra';
import fs2__default from 'fs-extra';
import path2, { sep } from 'path';
import originalFetch from 'isomorphic-unfetch';
import retry from 'fetch-retry';
import { nanoid } from 'nanoid';
import { execSync } from 'child_process';
import { createHash } from 'crypto';
import chalk from 'chalk';

var __require=(x=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(x,{get:(a,b)=>(typeof require<"u"?require:a)[b]}):x)(function(x){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+x+'" is not supported')});var getActualPackageVersions=async packages=>{let packageNames=Object.keys(packages);return Promise.all(packageNames.map(getActualPackageVersion))},getActualPackageVersion=async packageName=>{try{let packageJson=await getActualPackageJson(packageName);return {name:packageName,version:packageJson.version}}catch{return {name:packageName,version:null}}},getActualPackageJson=async packageName=>{let resolvedPackageJson=__require.resolve(path2.join(packageName,"package.json"),{paths:[process.cwd()]});return await fs2.readJson(resolvedPackageJson)},getStorybookCoreVersion=async()=>(await Promise.all(["@storybook/core-common","@storybook/core-server"].map(getActualPackageVersion))).find(v=>v.version)?.version;var monorepoConfigs={Nx:"nx.json",Turborepo:"turbo.json",Lerna:"lerna.json",Rush:"rush.json",Lage:"lage.config.json"},getMonorepoType=()=>{let projectRootPath=getProjectRoot();if(!projectRootPath)return;let monorepoType=Object.keys(monorepoConfigs).find(monorepo=>{let configFile=path2.join(projectRootPath,monorepoConfigs[monorepo]);return fs2__default.existsSync(configFile)});if(monorepoType)return monorepoType;if(!fs2__default.existsSync(path2.join(projectRootPath,"package.json")))return;if(fs2__default.readJsonSync(path2.join(projectRootPath,"package.json"))?.workspaces)return "Workspaces"};function regexpEscape(str){return str.replace(/[-[/{}()*+?.\\^$|]/g,"\\$&")}function cleanPaths(str,separator=sep){if(!str)return str;let stack=process.cwd().split(separator);for(;stack.length>1;){let currentPath=stack.join(separator),currentRegex=new RegExp(regexpEscape(currentPath),"g");str=str.replace(currentRegex,"$SNIP");let currentPath2=stack.join(separator+separator),currentRegex2=new RegExp(regexpEscape(currentPath2),"g");str=str.replace(currentRegex2,"$SNIP"),stack.pop();}return str}function sanitizeError(error,pathSeparator=sep){try{error=JSON.parse(JSON.stringify(error,Object.getOwnPropertyNames(error)));let errorString=cleanPaths(JSON.stringify(error),pathSeparator);return JSON.parse(errorString)}catch(err){return `Sanitization error: ${err?.message}`}}var knownRenderers=["html","react","svelte","vue3","preact","server","vue","web-components","angular","ember"],knownBuilders=["builder-webpack5","builder-vite"];function findMatchingPackage(packageJson,suffixes){let{name="",version,dependencies,devDependencies,peerDependencies}=packageJson,allDependencies={[name]:version,...dependencies,...devDependencies,...peerDependencies};return suffixes.map(suffix=>`@storybook/${suffix}`).find(pkg=>allDependencies[pkg])}var getFrameworkPackageName=mainConfig=>{let packageNameOrPath=typeof mainConfig?.framework=="string"?mainConfig.framework:mainConfig?.framework?.name;if(!packageNameOrPath)return null;let normalizedPath=path2.normalize(packageNameOrPath).replace(new RegExp(/\\/,"g"),"/");return Object.keys(frameworkPackages).find(pkg=>normalizedPath.endsWith(pkg))||cleanPaths(packageNameOrPath).replace(/.*node_modules[\\/]/,"")};async function getFrameworkInfo(mainConfig){if(!mainConfig.framework)return {};let frameworkName=getFrameworkPackageName(mainConfig);if(!frameworkName)return {};let frameworkOptions=typeof mainConfig.framework=="object"?mainConfig.framework.options:{},frameworkPackageJson=await getActualPackageJson(frameworkName),builder=findMatchingPackage(frameworkPackageJson,knownBuilders),renderer=findMatchingPackage(frameworkPackageJson,knownRenderers);return {framework:{name:frameworkName,options:frameworkOptions},builder,renderer}}function getChromaticVersionSpecifier(packageJson){let dependency=packageJson.dependencies?.chromatic||packageJson.devDependencies?.chromatic||packageJson.peerDependencies?.chromatic;return dependency||(packageJson.scripts&&Object.values(packageJson.scripts).find(s=>s?.match(/chromatic/))?"latest":void 0)}var metaFrameworks={next:"Next","react-scripts":"CRA",gatsby:"Gatsby","@nuxtjs/storybook":"nuxt","@nrwl/storybook":"nx","@vue/cli-service":"vue-cli","@sveltejs/kit":"sveltekit"},sanitizeAddonName=name=>cleanPaths(name).replace(/\/dist\/.*/,"").replace(/\.[mc]?[tj]?s[x]?$/,"").replace(/\/register$/,"").replace(/\/manager$/,"").replace(/\/preset$/,""),computeStorybookMetadata=async({packageJson,mainConfig})=>{let metadata={generatedAt:new Date().getTime(),hasCustomBabel:!1,hasCustomWebpack:!1,hasStaticDirs:!1,hasStorybookEslint:!1,refCount:0},allDependencies={...packageJson?.dependencies,...packageJson?.devDependencies,...packageJson?.peerDependencies},metaFramework=Object.keys(allDependencies).find(dep=>!!metaFrameworks[dep]);if(metaFramework){let{version}=await getActualPackageVersion(metaFramework);metadata.metaFramework={name:metaFrameworks[metaFramework],packageName:metaFramework,version};}let monorepoType=getMonorepoType();monorepoType&&(metadata.monorepo=monorepoType);try{let packageManagerType=await detect({cwd:getProjectRoot()}),packageManagerVerson=await getNpmVersion(packageManagerType);metadata.packageManager={type:packageManagerType,version:packageManagerVerson};}catch{}metadata.hasCustomBabel=!!mainConfig.babel,metadata.hasCustomWebpack=!!mainConfig.webpackFinal,metadata.hasStaticDirs=!!mainConfig.staticDirs,mainConfig.typescript&&(metadata.typescriptOptions=mainConfig.typescript);let frameworkInfo=await getFrameworkInfo(mainConfig);mainConfig.refs&&(metadata.refCount=Object.keys(mainConfig.refs).length),mainConfig.features&&(metadata.features=mainConfig.features);let addons={};mainConfig.addons&&mainConfig.addons.forEach(addon=>{let addonName,options;typeof addon=="string"?addonName=sanitizeAddonName(addon):(options=addon.options,addonName=sanitizeAddonName(addon.name)),addons[addonName]={options,version:void 0};});let chromaticVersionSpecifier=getChromaticVersionSpecifier(packageJson);chromaticVersionSpecifier&&(addons.chromatic={version:void 0,versionSpecifier:chromaticVersionSpecifier,options:void 0}),(await getActualPackageVersions(addons)).forEach(({name,version})=>{addons[name].version=version;});let addonNames=Object.keys(addons),storybookPackages=Object.keys(allDependencies).filter(dep=>dep.includes("storybook")&&!addonNames.includes(dep)).reduce((acc,dep)=>({...acc,[dep]:{version:void 0}}),{});(await getActualPackageVersions(storybookPackages)).forEach(({name,version})=>{storybookPackages[name].version=version;});let language=allDependencies.typescript?"typescript":"javascript",hasStorybookEslint=!!allDependencies["eslint-plugin-storybook"],storybookInfo=getStorybookInfo(packageJson),storybookVersion=storybookPackages[storybookInfo.frameworkPackage]?.version;return {...metadata,...frameworkInfo,storybookVersion,storybookVersionSpecifier:storybookInfo.version,language,storybookPackages,addons,hasStorybookEslint}},cachedMetadata,getStorybookMetadata=async _configDir=>{if(cachedMetadata)return cachedMetadata;let{packageJson={}}=readPkgUp.sync({cwd:process.cwd(),normalize:!1})||{},configDir=(_configDir||getStorybookConfiguration(packageJson?.scripts?.storybook||"","-c","--config-dir"))??".storybook",mainConfig=await loadMainConfig({configDir});return cachedMetadata=await computeStorybookMetadata({mainConfig,packageJson}),cachedMetadata};var oneWayHash=payload=>{let hash=createHash("sha256");return hash.update("storybook-telemetry-salt"),hash.update(payload),hash.digest("hex")};function normalizeGitUrl(rawUrl){return rawUrl.trim().replace(/#.*$/,"").replace(/^.*@/,"").replace(/^.*\/\//,"").replace(":","/")}var anonymousProjectId,getAnonymousProjectId=()=>{if(anonymousProjectId)return anonymousProjectId;let unhashedProjectId;try{let projectRoot=getProjectRoot(),projectRootPath=path2.relative(projectRoot,process.cwd()),originBuffer=execSync("git config --local --get remote.origin.url",{timeout:1e3,stdio:"pipe"});unhashedProjectId=`${normalizeGitUrl(String(originBuffer))}${projectRootPath}`,anonymousProjectId=oneWayHash(unhashedProjectId);}catch{}return anonymousProjectId};var operation=Promise.resolve(),setHelper=async(eventType,body)=>{let lastEvents=await cache.get("lastEvents")||{};lastEvents[eventType]={body,timestamp:Date.now()},await cache.set("lastEvents",lastEvents);},set=async(eventType,body)=>(await operation,operation=setHelper(eventType,body),operation);var upgradeFields=event=>{let{body,timestamp}=event;return {timestamp,eventType:body?.eventType,eventId:body?.eventId,sessionId:body?.sessionId}},UPGRADE_EVENTS=["init","upgrade"],RUN_EVENTS=["build","dev","error"],lastEvent=(lastEvents,eventTypes)=>{let descendingEvents=eventTypes.map(eventType=>lastEvents?.[eventType]).filter(Boolean).sort((a,b)=>b.timestamp-a.timestamp);return descendingEvents.length>0?descendingEvents[0]:void 0},getPrecedingUpgrade=async(events=void 0)=>{let lastEvents=events||await cache.get("lastEvents")||{},lastUpgradeEvent=lastEvent(lastEvents,UPGRADE_EVENTS),lastRunEvent=lastEvent(lastEvents,RUN_EVENTS);if(lastUpgradeEvent)return !lastRunEvent?.timestamp||lastUpgradeEvent.timestamp>lastRunEvent.timestamp?upgradeFields(lastUpgradeEvent):void 0};var SESSION_TIMEOUT=1e3*60*60*2,sessionId;var getSessionId=async()=>{let now=Date.now();if(!sessionId){let session=await cache.get("session");session&&session.lastUsed>=now-SESSION_TIMEOUT?sessionId=session.id:sessionId=nanoid();}return await cache.set("session",{id:sessionId,lastUsed:now}),sessionId};var URL=process.env.STORYBOOK_TELEMETRY_URL||"https://storybook.js.org/event-log",fetch=retry(originalFetch),tasks=[],addToGlobalContext=(key,value)=>{globalContext[key]=value;},globalContext={inCI:Boolean(process.env.CI),isTTY:process.stdout.isTTY},prepareRequest=async(data,context,options)=>{let{eventType,payload,metadata,...rest}=data,sessionId2=await getSessionId(),eventId=nanoid(),body={...rest,eventType,eventId,sessionId:sessionId2,metadata,payload,context};return fetch(URL,{method:"POST",body:JSON.stringify(body),headers:{"Content-Type":"application/json"},retries:3,retryOn:[503,504],retryDelay:attempt=>2**attempt*(typeof options?.retryDelay=="number"&&!Number.isNaN(options?.retryDelay)?options.retryDelay:1e3)})};async function sendTelemetry(data,options={retryDelay:1e3,immediate:!1}){let{eventType,payload,metadata,...rest}=data,context=options.stripMetadata?globalContext:{...globalContext,anonymousId:getAnonymousProjectId()},request;try{request=prepareRequest(data,context,options),tasks.push(request),options.immediate?await Promise.all(tasks):await request;let sessionId2=await getSessionId(),eventId=nanoid(),body={...rest,eventType,eventId,sessionId:sessionId2,metadata,payload,context};await set(eventType,body);}catch{}finally{tasks=tasks.filter(task=>task!==request);}}var TELEMETRY_KEY_NOTIFY_DATE="telemetry-notification-date",logger=console,notify=async()=>{await cache.get(TELEMETRY_KEY_NOTIFY_DATE,null)||(cache.set(TELEMETRY_KEY_NOTIFY_DATE,Date.now()),logger.log(),logger.log(`${chalk.magenta.bold("attention")} => Storybook now collects completely anonymous telemetry regarding usage.`),logger.log("This information is used to shape Storybook's roadmap and prioritize features."),logger.log("You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:"),logger.log(chalk.cyan("https://storybook.js.org/telemetry")),logger.log());};var telemetry=async(eventType,payload={},options={})=>{eventType!=="boot"&&await notify();let telemetryData={eventType,payload};try{options?.stripMetadata||(telemetryData.metadata=await getStorybookMetadata(options?.configDir));}catch(error){telemetryData.payload.metadataErrorMessage=sanitizeError(error).message,options?.enableCrashReports&&(telemetryData.payload.metadataError=sanitizeError(error));}finally{let{error}=telemetryData.payload;error&&(telemetryData.payload.error=sanitizeError(error)),(!telemetryData.payload.error||options?.enableCrashReports)&&(process.env?.STORYBOOK_TELEMETRY_DEBUG&&(logger$1.info(`
[telemetry]`),logger$1.info(JSON.stringify(telemetryData,null,2))),await sendTelemetry(telemetryData,options));}};

export { addToGlobalContext, computeStorybookMetadata, getPrecedingUpgrade, getStorybookCoreVersion, getStorybookMetadata, metaFrameworks, oneWayHash, sanitizeAddonName, telemetry };
